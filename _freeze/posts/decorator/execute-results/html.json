{
  "hash": "3d878c8b16b079e5cac3d2e099991550",
  "result": {
    "markdown": "---\ntitle: \"Add to class 函數裝飾\"\nauthor: \"ChoCho\"\ndate: \"2023-01-23\"\ndate-format: iso\ndate-modified: last-modified\ncategories: [decorator, Python]\n# image: \"image.jpg\"\n# jupyter: python3\nreference-location: margin\ncitation-location: margin\n---\n\n- 取自 [https://d2l.ai/chapter_linear-regression/oo-design.html#utilities](https://d2l.ai/chapter_linear-regression/oo-design.html#utilities).\n\n- See [https://www.runoob.com/w3cnote/python-func-decorators.html](https://www.runoob.com/w3cnote/python-func-decorators.html).\n\n- 重要準則:\n  \n  ```python\n  @f\n  def g():\n    ...\n  ```\n  \n  等價於\n\n  ```python\n  g = f(g)\n  ```\n\n## 使用方式\n\n定義如下的 `add_to_class`.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef add_to_class(Class):\n  def wrapper(obj):\n    setattr(Class, obj.__name__, obj)\n  return wrapper\n```\n:::\n\n\n假如我們有一個 class `A`, 且有個 method `double`.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nclass A:\n  def double(self,t):\n    return 2*t\n```\n:::\n\n\n令 `a` 為 `A` 的 instance.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\na = A()\n```\n:::\n\n\n則我們可以呼叫 `a.double(3)`.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\na.double(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n6\n```\n:::\n:::\n\n\n現在假如我們想修改 A 的 method `double`,\n可用如下.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n@add_to_class(A)\ndef double(self,t):\n  return 7*t\n```\n:::\n\n\n則可以發現: 不需重新令 `a` 是 `A` 的 instance, `a` 的 `double` 都已經變更.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\na.double(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n21\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# 另一個 A 的 instance\naa = A()\naa.double(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n21\n```\n:::\n:::\n\n\n## 解析 code\n\n回顧 `add_to_class` 為\n\n```python\ndef add_to_class(Class):\n  def wrapper(obj):\n    setattr(Class, obj.__name__, obj)\n  return wrapper\n```\n\n且\n\n```python\n@add_to_class(A)\ndef double(self,t):\n  return 7*t\n```\n\n等價於 `double = add_to_class(A)(double)`.\n\n::: {.callout-important}\n這裡會令 `double` 為 `add_to_class(A)(double)`.\n所以要注意不會覆蓋到舊有的變數.\n可以單獨執行 `double` 會發現不報錯 (不會 return 任何東西).\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndouble, type(double)\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\n(None, NoneType)\n```\n:::\n:::\n\n\n:::\n\n所以有執行了 `add_to_class(A)(double)`[^1] 這指令.\n\n[^1]: 這裡 `add_to_class(A)` 不 是 class, 而是 `wrapper`.\n\n所以有執行 `setattr(Class, obj.__name__, obj)`,\n其中 `Class = A`, `obj = double`.\n\n所以相當於執行了 `setattr(A, double, 7*t)`[^2][^3].\n\n[^2]: 這裡的 `obj.__name__` 相當於 obj 的名字. 在這就是 double.\n\n[^3]: 這裡 `setattr(Class, obj.__name__, obj)` 的第三分量 `obj` 相當於 `double` return 的東西, 所以就是 `7*t`.\n\n\n\n###\n\nTODO: \n\n- https://www.runoob.com/w3cnote/python-func-decorators.html\n\n",
    "supporting": [
      "decorator_files"
    ],
    "filters": [],
    "includes": {}
  }
}